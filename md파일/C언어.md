C++은 C언어의 문법체계를 따르기 때문에 먼저 학습이 되어야함.

Tool은 Visual Studio를 사용.

Day1

C언어는 시스템 프로그래밍 이 주 목적. 그러므로 시스템 관련 배경지식을 알 필요성.

▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
컴퓨터에서 누가 명령어를 읽는가?
	CPU(Central Processing Unit)

어디에서 명령어를 읽는가?
	CPU는 연산에 특화되어 있는 것. 그러므로 데이터를 저장하는 공간은 현저히 작다.
	이를 임시공간, 즉 레지스터라고 하는데 64비트 CPU경우 8바이트 16개 정도.
	그러므로 저장에 특화된 장치가 필요. == 메모리(램) => 16진수로 고유의 주소가 존재한다.
	램은 휘발성이기에 전력이 없으면 데이터가 날아감. 그러기에 하드디스크 ssd등이 필요.
	램은 데이터를 읽는 속도가 빠르긴 하지만 CPU에 비해서는 엄청 낮다.
	이 때문에 CPU에 데이터를 잠시 보관하려는 필요가 생기는데 이것이 == 캐시(cache)이다.

	정리하면,
	프로그램을 실행한다 == 하드디스크에서 RAM으로 프러그램 명령어를 불러온다.
	이후 RAM에서 필요한 명령어를 CPU가 불러와 실행한다.
	
명령어를 어떻게 작성하는가? 
	CPU는 2진수의 명령어 체계를 따른다.
	이를 사람이 알아보기 쉽게 하기위해 언어가 필요.
	
	명령어를 쓰기위해
	램의 어디에 데이터를 쓸지
	램에 무엇을 쓸지
	해당 위치에 얼마만큼 공간에 쓸지
	에 대한 설정이 필요.

	CPU가 명령어를 읽어들이는 방법.
	하드디스크에서 프로그램 정보를 RAM에 복사함. ->(이를 운영체제가 함.)
	프로그램의 시작 위치로 RIP를 설정함. ->
	램의 RIP(명령어 주소 레지스터)에 위치한 명령어를 읽어옴.

	사람이 이해하기 쉽게 작성하는 명령어 == 프로그래밍 언어
	이 명령어를 어셈블리로 바꿔주는 과정 == 컴파일
	(어셈블리란? = CPU 가 직접적으로 해석하는 명령어)

▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
여기까지 정리

1. 모든 연산은 CPU 에서 수행된다. 정확히 말하자면, CPU 의 자그마한 레지스터 상에서 수행된다. 64 비트 CPU 의 경우 레지스터의 크기는 8 바이트 이다.

2. CPU 는 무슨 연산을 할 지 알려주는 명령어와, 명령어를 실행하기 위해 필요로 하는 데이터를 메모리 (램) 에서 읽는다.

3. 우리가 프로그램을 실행한다는 것은 하드 디스크에 잠들어 있는 명령어들과 데이터를 메모리에 쓰는 것이라 생각하면 된다. 그리고 운영체제가 CPU 에 처음으로 실행해야 할 명령어의 주소값을 전달함으로써 프로그램이 시작된다.

4. CPU 에는 캐시가 있어서 메모리 접근 횟수를 줄일 수 있다.

5. 각 프로그램들은 마치 자신이 방대한 메모리 공간 전체를 사용하는 것 처럼 생각하며 작동한다.

6. CPU 에서 참조하는 주소값은 실제 물리 메모리 주소값이 아니라 가상 메모리 주소값이다.

7. 가상 메모리 주소값은 각 프로그램의 페이지 테이블을 통해서 실제 메모리 주소값으로 변환된다.



Day2
▶▶▶▶▶▶▶▶▶▶▶
C언어의 컴파일러 종류
1. GCC(리눅스 커널을 컴파일)
2. Clang(구글,맥)
3. MSVC(코드 공개x, micro사의 컴파일러)
	- IDE(통합개발환경)(컴파일러, 코드 편집기, 디버거[원래는 따로 설치해야함. / IDE를통해 한번에!])
	https://visualstudio.microsoft.com/downloads/ => C++용 설치


▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
설치 후 프로젝트 만들어 소스추가 -> C++파일 -> 확장명을 .c로 만들기
HelloWorld프로젝트에서 main.c라는 파일에 
#include <stdio.h>
int main(){
    printf("Hello World! \n");
    return 0;
}
소스 입력후 ctrl + F5 누르면 실행.

소스분석
	#include <> : 괄호안의 파일 내용을 이곳에 불러와라
	<stdio.h> : Header파일.(Standard Input Output - 표준 입출력) 즉 입출력을 담당하는 기능들을 불러온다!
	int main(){} : 함수이다. main함수가 C프로그램의 시작점. {} 안의 내용이 실행된다.
		    int는 return값으로 main함수가 끝난 뒤 되돌려줄 데이터 타입.
	printf : 화면에 출력을 하는 함수(이내용).(stdio.h파일 필요!) 
	\n : 줄바꿈

(이때 한 프로젝트에서 main이 여러개면 충돌 날 수 있다. 그러므로 이전에 한것 속성에서 빌드에서 제외 처리를 해줘야한다.)



Day3
▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
노트북에서는 Visual Studio Code를 사용할 것임.
https://sourceforge.net/projects/mingw/ 여기서 컴파일러 다운(https://www.youtube.com/watch?v=3-PD_AUSOLM 참고)
환경변수 추가를 위해 path에 C:\MinGW\bin경로 추가.

cmd에서 	gcc -v입력 후 컴파일러 잘 깔렸나 확인.
	g++ -v 도 마찬가지.

노트북에서 컴파일 및 실행
ctrl alt c
ctrl alt r

▶▶▶▶▶▶▶▶▶▶▶
C언어에서 주석은 2가지.
	1. /* */
	2. //

▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
10진법 : 253 = (2 X 10^2) + (5 X 10^1) + (3 X 10^0)

2진법 : 6 = 4 + 2 = (1 X 2^2) + (1 X 2^1) + (0 X 2^0) = 110(2)
	202를 만들어봐라. = 11001010(2) 나누기 -> 나머지값.(역순으로 입력하면 됨.)

​16진법 : 0,1,2,...,9,A,B,C,D,E,F를 이용하여 숫자를 표현
	123=7×16+11=0x7B(A부터 10)(이때 0x는 16진수를 의미)
	19 = 1×16+3 = 0x13



Day4

▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
컴퓨터의 데이터를 저장하는 공간은 크게 두 부류로 나뉨.
	1. 휘발성 메모리(종료시 데이터가 날아감_RAM_랜덤으로 접근 가능.)
		RAM
	2. 비휘발성 메모리(종료해도 데이터 남아 있음_ROM_순차적 접근 가능.)
		CD, DVD, 하드디스크

컴퓨터의 한 개의 메모리 소자에는 0 혹은 1의 값을 보관할 수 있다.
이것을 1bit라고 하는데 1bit가 8개가 모여 8byte가 된다. 	==>  	8bit == 1byte
1byte로 나타낼 수 있는 경우의 수는 2^8이 되겠다.(256)

컴퓨터에서 연산을 담당하는 CPU에서는 레지스터(register)라는 작은 메모리 공간이 있는데, 이곳에 값을 불러놓고 연산을 수행한다.
예를 들어 a + b를 하기위해 a와 b를 잠시 써놓는 부분.
이 레지스터의 크기가 컴퓨터 상에서 연산이 실행되는 최소단위이며, 이 크기를 워드(word)라고 한다.
1word는 32bit, 즉 4byte이다. 			==> 	1word == 8byte == 32bit


▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
여기까지 정리

1. 이진법은 0과 1로, 10진법은 0~9로, 16진법은 0~F로 수를 표현한다.

2. 1bit는 이진수로 숫자 1개를 의미하고 8bit == 1byte가 된다. 1byte는 0부터 255까지의 수를 표현할 수 있다.
	(4byte == 1word)

3. 컴퓨터의 데이터를 저장하는 공간은 크게 RAM과 ROM으로 나뉜다.
	이때 잠시 데이터를 잠시 기록해 놓는 공간이 메모리, 즉 RAm이다.

4. word의 개념을 통해 알 수 있듯, 대부분의 컴퓨터는 4byte 혹은 8byte 단위로 데이터를 처리한다.


▶▶▶▶▶▶▶▶▶▶
변수를 왜 사용할까?
예를들어 32bit의 CPU가 있다고 하면, RAM은 2^32개의 메모리 방을 가질 수 있게된다.
보통 이는 16진법으로 주소값을 나타내는데, 특정 데이터를 이 RAM에 저장하고, 사용할때
꺼내거나 수정하거나 삭제 등을 할때 복잡하고 긴 주소를 일일이 써야한다.
이때 변수를 사용하게 되면 알아서 메모리 어딘가에 방을 할당해주고, 해당 변수로 사용할 수 있게 해준다.

변수의 종류
char, short, int, long, long long, float, double등이 있음(데이터 크기 순서)
(이때 float와 double은 실수를 나타내는데 float은 f를 붙여줌.)

ex)
int main(){
int a;
a = 10;
printf("a의 값은 : %d ",a);
return 0;
}
이때 printf("a의 값은 : %d ",a); 부분에서 %d는 a의 위치를 의미한다.
(정확히는 처음 "" 다음에 오는 첫번째 변수를 10진수로 표현하라)
이외에 %o, %x등이 있는데, 이는 각각 8진수로, 16진수로 출력하라는 의미이다.
추가적으로 실수를 출력할 때는 %f를 사용해야 한다.

활용예제
	1. printf("a : %.2f ",a);	--소수점 이하 둘째자리 까지만 출력하라.
	2. printf("a : %5d ",a);	--출력을 5자리로 맞춰라.(6자리인 수의 경우 6개 모두 표시)
	3. printf("a : %6.3f, a");	--소수점 이하 셋째자리 까지만 표시하되, 전체자리는 6자리로.(위의 두개 중첩)


▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
여기까지 정리

1. 변수는 데이터를 임시로 저장하는 공간. 자유롭게 쓰고 지울 수 있음.

2. 각 변수에는 데이터 타입이 있어, 알맞게 데이터를 보관 가능.

3. printf로 출력시 %d, %o, %x, %f등이 있다.



Day5

산술연산자, 대입연산자
비트연산자 (1100 / 1010)
	& = 모두 1이면 1.
	|   = 둘중 하나만 1이여도 모두 1이 됨.
	^  = 두 수가 달라야 1이 됨.
	~  = 반전연산(~1100 => 0011)
		주의) int a = 10101111; => ~a == 11111111 11111111 01010000 => 즉 0xFFFFFF50됨.
	<< = 왼쪽으로 이동 후 마지막에 0추가(앞자리에는 들어갈 자리가 없다면 버려짐)
	>> = 반대로 오른쪽으로 이동.(0011001 >> 3 == 0000011)
	
연산에도 순서가 있다.(좌/우에 따라)



Day6

▶▶▶▶▶▶▶▶▶▶▶▶▶▶
컴퓨터가 음수를 표현하는 방법.
가정으로 0001(=7)을 더해 0000을 만들 수 있는 이진법으로 나타낼 수 있는 수가 있을까?
이때 덧셈시 컴퓨터가 4비트만 기억한다고 가정할 때, 가장 적당한 수는 1001(9)가 될것.
둘을 더하면 10000(=26)이 되는데 이때 4비트만 기억한다 했으므로 맨 앞의 1은 버려지니 0000만 남게된다.
== 이를 2의 보수 표현이라 한다. 이는 공식이 있는데, 비트를 모두 반전시키고 마지막에 1을 더하면 된다.
	그리고 맨 앞이 1로 시작하면 음수이다.

▶▶▶▶▶
오버플로우
이 부분은 실제로 정수부분에서 적용이 되는데, int의 최대값인 2147483647에 1을 더하여 출력을 하게 되면,
-2147483648이 출력된다. 이처럼 최대 범위보다 큰 수를 대입함으로써 발생하는 문제를 오버플로우(overflow)라고 한다.


특이하게 unsigned int라는 데이터 타입이 있는데, 이는 0~4294967295까지 표현 가능하다.(int형과 범위는 같지만 음수를 표현 x)
이 자료형에 -1을 대입하면 4294967295라는 값이 나온다. (printf("b : %u \n",b));
이때 %u는 unsigned 타입으로 해석하라는 의미임.
다시, 이 자료형의 최대값에 1을 더하면 자료형의 크기를 초과하는 값이 되버려 0이 출력된다.

이처럼 오버플로우는 모든 자료형에서 나타날 수 있고, 오류처리되지 않으니 조심해야한다.


Day7

▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
컴퓨터는 단지 0과 1을 처리할 뿐이다.
이때 문자는 어떻게 처리를 하나?
char라는 자료형이 있지만, 이는 문자 자체가 아니라 숫자를 문자 형태로 사용하는 것.
char a = 'a';
printf("a의 값 : %d , a의 문자 : %c",a,a);
출력의 결과는 각각 97, a 이렇게 나온다.

이를 변환해주는 것이 %d, %c가 되겠네.(%d는 10진수로, %c는 문자로)
(이는 ASCII코드로 정해져 있다.)

이러던 중 ASCII코드로는 영어밖에 표현을 할 수 없기에 더 많은 문자를 해야할 필요성이 대두됨.
그래서 나온 새로운 문자형식체계가 Unicode임.

▶▶▶▶▶▶▶▶▶▶
scanf의 도입(입력함수)
printf가 각 변수를 출력할 포맷(%d, %c, %f등)이 각각 다르듯,
scanf도 각 변수의 타입마다 포맷을 달리해야함.

	printf("char형 변수 입력 : ");
	scanf("%c", &ch);

	printf("short형 변수 입력 : ");
	scanf("%hd", &sh);

	printf("int형 변수 입력 : ");
	scanf("%d", &i);

	printf("long형 변수 입력 : ");
	scanf("%ld", &lo);

	printf("float형 변수 입력 : ");
	scanf("%f", &fl);

	printf("double형 변수 입력 : ");
	scanf("%lf", &du);
이정도는 외우는게 좋을 듯 하다.
(scanf반환 무시 오류가 뜨면 #pragma warning(disable:4996) 추가 하여 경고 무시해도 됨.


▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
여기까지 정리

1. 오버플로우란? : (자료형의)최대 범위보다 큰 수를 대입함으로써 발생하는 문제.

2. scanf를 활용할때도 printf처럼 변수의 타입마다 포맷을 달리한다.



Day8

조건문 if / else if / else의 사용법(자바와 동일하다.)

논리연산자
&& == AND	(&한개는 비트 사이의 AND연산이라고 한다.)
||    == OR
!    ==  NOT


Day9

반복문(자바와 동일하게 사용한다.) 
for
while


switch문도 자바와 동일하다.




Day10

배열이란 : 컴퓨터 메모리상에 같은 타입의 변수를 연속적으로 여러개를 한번에 정의하는 방법. 
















▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶▶
노트북 한글 인코딩은 우측하단 encoding으로 해결 모두 가능.
homework과제

문제 1 (난이도 : 中) => homework_1.c 완료
N 줄인 삼각형을 출력한다. 단, 사용자로 부터 임의의 N 을 입력 받는다. 아래는 N = 3 일 때의 출력 예시 이다.

  *
 ***
*****
문제 2 (난이도 : 中上)
위와 동일한 형태를 취하되, 역 삼각형을 출력한다. 아래는 N = 3 일 때의 출력 예시 이다.

*****
 ***
  *
문제 3 (난이도 : 下)
1000 이하의 3 또는 5 의 배수인 자연수들의 합을 구한다.

문제 4 (난이도 : 中)
1000000 이하의 피보나치 수열 ( N 번째 항이 N - 1 번째 항과 N - 2 번째 항으로 표현되는 수열, 시작은 1,1,2,3,5,8,...) 의 짝수 항들의 합을 구한다

문제 5 (난이도 : 下)
사용자로 부터 N 값을 입력 받고 1 부터 N 까지의 곱을 출력한다.

문제 6 (난이도 : 中)
다음 식을 만족하는 자연수 a,b,c 의 개수를 구하여라

  i) a + b + c = 2000
  ii) a ＞ b > c, a,b,c 는 모두 자연수
문제 7 (난이도 : 中上)
임의의 자연수 N 을 입력 받아 N 을 소인수 분해 한 결과를 출력하여라. 예를 들어서 N = 18 일 경우

N = 18 18 = 2 * 3 * 3

문제 8 (난이도 : 上)
문제 7 에서 만든 프로그램의 속도를 향상 시킬 수 있는 방법은 없을까? 큰 수를 빠르게 소인수분해 할 수 있는 방법들을 찾아 프로그램에 적용시켜 보아라. 예를 들어서 N 의 제곱근 이하의 정수들만 처리한다던지, Lucas- Lehmer 판정법을 이용해 소수인지 아닌지 판정한다던지 등등..

위의 문제 8가지 만들어보기.(switch문 활용한 예제도 만들어보기.)
	